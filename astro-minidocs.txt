Astro components (.astro): HTML-only templates, render at build-time or SSR, zero client-side runtime by default. Structure: Component Script (JavaScript), Component Template (HTML + JS Expressions). Component Script: Code fence (---) for JavaScript code. Import components, data, fetch APIs, create variables. Component Template: HTML output. Supports JS expressions, Astro tags, imported components, Astro directives. Component Props: Defined on Astro.props. Example: const { title } = Astro.props; Usage: . Can define Props interface in TypeScript. Default values: const { greeting = "Hello", name } = Astro.props;. Slots: placeholder for external HTML content. Default slot renders all child elements. Named Slots: . Use slot="my-slot" attribute on child element. Fallback Content: Content rendered when no matching children passed to a slot. Transferring slots: Can be transferred to other components using name and slot attributes. HTML Components: .html files as components. No frontmatter, server-side imports, or dynamic expressions. Pages are files in src/pages/. Supported file types: .astro, .md, .mdx, .html, .js/.ts (endpoints). File-based routing. 404.astro/md for custom 404 page. 500.astro for custom 500 page (error prop). export const partial = true for partial pages. Astro component syntax: superset of HTML. JSX-like Expressions: Inject JavaScript variables into HTML using {}. Dynamic vs reactive: Values are dynamic but not reactive. Variables: const name = "Astro"; Hello {name}! Dynamic Attributes: Use {} to pass attribute values. Attributes are converted to strings. Event handlers not directly assignable, use client-side scripts. Dynamic HTML: Use JSX-like functions for dynamic HTML. {items.map((item) => ({item}))} Conditional HTML: {visible && Show me!} Dynamic Tags: const Element = 'div'; Hello!. Variable names must be capitalized. No hydration directives. Fragments: or <>. Astro vs JSX: - Attributes: kebab-case instead of camelCase. - Multiple Elements: No need to wrap in a single element. - Comments: HTML or JavaScript-style. HTML comments in DOM, JS comments skipped. Layouts are Astro components for reusable UI structure. Layouts include a page shell, a <slot /> for content. Layouts can accept props. For Markdown/MDX, use the `layout` frontmatter property. MarkdownLayoutProps and MDXLayoutProps for type safety. Markdown/MDX layouts have access to file, url, frontmatter, headings, rawContent(), compiledContent(). Astro project structure: src/* (source code), public/* (unprocessed assets), package.json, astro.config.mjs, tsconfig.json. src/ contains components, layouts, pages, styles. src/pages/ is required for routing. public/ is for static assets. astro.config.mjs configures Astro. tsconfig.json configures TypeScript. Rendering Modes: Pre-rendered (static), On-demand (server-side rendering SSR). output: 'static' - HTML created at build time (SSG). output: 'server' - on-demand routes. output: 'hybrid' - mostly static, some on-demand. Server or hybrid mode for API endpoints, protected pages, frequently changing content. Static sites can include Astro islands for interactive UI components. SSR requires an adapter. Middleware to intercept and transform response data. On-demand rendering features cookies, Response and Request objects, HTML streaming. Community Educational Content: Courses, tutorials, recipes, and guides for learning Astro. Examples: Astro Web Framework Crash Course, Astro Crash Course, Understanding Astro ebook, official recipes for Vite plugins, custom image components, API routes, HTML forms, Docker, dynamic images, i18n, remark plugins for time and reading. Talks Interviews and Streams. Curated list of community videos introducing Astro. Provides links to external video content. Check Astro Blog or newsletter for more content. Subscribe to Astro Community Events Google Calendar for live events. Astro Islands: Interactive UI components in static HTML. Islands run independently, can share state. <MyReactComponent client:load /> turns static component interactive. Benefits: Performance, parallel loading. Supports React, Preact, Svelte, Vue, SolidJS. Astro is a web framework for content-driven websites. It is server-first, UI-agnostic and fast by default. Supports React, Preact, Svelte, Vue, Solid, Lit, HTMX, and web components. Contribute: Open source project, various ways to contribute including code, docs, and translations. Editor Setup: VS Code recommended (Astro extension: syntax, types, Intellisense). Zed (Astro extension: syntax, completion, formatting). Webstorm (Astro Language Server: syntax, completion, formatting). Other editors: Nova, Vim, Neovim, Emacs, Sublime Text (community extensions). In-browser: StackBlitz, CodeSandbox (syntax built-in), GitHub.dev, Gitpod (VS Code extension). Linters: ESLint (plugin), Stylelint (config). Formatter: Prettier (plugin). Install: `npm install -D prettier prettier-plugin-astro`. .prettierrc.mjs: `export default { plugins: ['prettier-plugin-astro'], overrides: [{ files: '*.astro', options: { parser: 'astro' } }] }`. Format: `npx prettier . --write`. Astro DB: SQL database for Astro. Local or Astro Studio hosted. Install: astro add db. Config: db/config.ts with defineDb, defineTable, column. Tables define data structure with columns of types: text, number, boolean, date, json. Define table relationships with references. Seed db with db/seed.ts and db.insert(). Query with Drizzle ORM via db object: db.select(), db.insert(), db.delete(), filter with where(), batch queries with db.batch(), join tables. Astro Studio for hosted DB, CLI, web UI, deploy with --remote, use ASTRO_STUDIO_APP_TOKEN. Schema changes: astro db push --remote, force reset with --force-reset. Rename tables via multi-step process. Push data with astro db execute --remote. Connect to remote DB with --remote flag in dev/build. Integrations: extendDb(), defineDbIntegration(), asDrizzleTable(). Self-hosted option with ASTRO_DATABASE_FILE, advanced, data loss risk. Authentication: Guides for authentication with Lucia Auth, Auth.js, and Clerk. Auth.js: Install: npx astro add auth-astro. getSession(Astro.request): Fetches the user’s session. Clerk: Install: npm install @clerk/astro. Clerk components for managing visibility based on user authentication. Content Collections: Organize, validate, and type-safe content. Located in src/content/. Collection entry: .md, .mdx, .yaml, .json files. src/content/config.ts: Configure collections. defineCollection({type: 'content'|'data', schema}). Export in collections object. Zod for schemas: import { z } from 'astro:content'. Collection references: reference('other-collection'). Custom slugs: Add slug property to frontmatter. Querying: getCollection(collectionName, filter?: ({ id, data, slug }) => boolean): Returns all entries. Filter by id, data, or slug. getEntry(collectionName, slug|id): Returns single entry. CollectionEntry type for components. entry.render(): Returns { Content, headings, remarkPluginFrontmatter? }. Static routes: getStaticPaths() uses getCollection() to generate paths. SSR: Use Astro.params to fetch entry with getEntry(). Data collections: {"$schema": "../../../.astro/collections/authors.schema.json"} for JSON schema. experimental.contentCollectionCache: Enable cached builds. Dates: Use ISO-8601 format (yyyy-mm-dd) with z.date(). fetch() makes HTTP requests. fetch(url, options): Returns data from a URL. Supports GraphQL queries. E-commerce with Astro. Supports payment processing overlays like Lemon Squeezy and Paddle. Also supports full-featured solutions like Snipcart. Endpoints: Create custom endpoints. GET function, returns Response. Static: /pages directory. SSR: Live server endpoints. export const prerender = false to opt-out. getStaticPaths() for dynamic routing. params property. request property. Methods: GET, POST, DELETE, ALL. redirect() utility. Environment variables. Access via import.meta.env. Statically replaced at build time. Server-side: all env vars available. Client-side: only PUBLIC_ prefixed vars available. Default env vars: import.meta.env.MODE, import.meta.env.PROD, import.meta.env.DEV, import.meta.env.BASE_URL, import.meta.env.SITE, import.meta.env.ASSETS_PREFIX. Set vars via .env files (not loaded in config files) or CLI (e.g. PUBLIC_POKEAPI=...). .env files can be mode-specific (.env.production, .env.development). TypeScript IntelliSense: define custom PUBLIC_ vars in src/env.d.ts interface ImportMetaEnv. Adds custom fonts to a project. Uses @font-face to define fonts. Fontsource simplifies using Google Fonts. Tailwind config can be updated to include custom fonts. Image handling in Astro: Use `src/` for optimization, `public/` for direct serving. <Image /> (astro:assets): src (required, file path or URL), alt (required), width, height, densities, widths, format, quality, inferSize, inferRemoteSize(). <Picture />: formats, fallbackFormat, pictureAttributes. <img />: For direct HTML control. src (required). getImage(): Creates images for use outside HTML. inferRemoteSize(url): Infer dimensions of remote images. Authorizing remote images: Configure image.domains or image.remotePatterns. Imports: Supports static assets, ESM syntax. Supported file types: .astro, .md, .js, .ts, .json, .css, images. public/ directory: static assets copied directly. Import statements: import { getUser } from './user.js'. JSX: require React, Preact, or Solid. TypeScript: supported, use .js/.jsx extensions. NPM Packages: import { Icon } from 'astro-icon'. JSON: import json from './data.json'. CSS: import './style.css'. CSS Modules: import styles from './style.module.css'; <div className={styles.error}>. Other Assets: import imgReference from './image.png'; <img src={imgReference.src} alt="". Aliases: in tsconfig.json, "paths": { "@components/*": ["src/components/*"] }. Astro.glob(): import many files at once. const posts = await Astro.glob('../pages/post/*.md'); Glob Patterns: ./pages/**/*.{md,mdx}. WASM: const wasm = await WebAssembly.instantiateStreaming(fetch('/example.wasm')); Node Builtins: import fs from 'node:fs/promises'. @astrojs/alpinejs: Astro integration adds Alpine.js. install: `npx astro add alpinejs`. Manual install: `npm install @astrojs/alpinejs alpinejs @types/alpinejs`. integrations: [alpine()]. Configuration: entrypoint: string; extends Alpine. Example: <div x-data="{ expanded: false }"> <button @click="expanded = ! expanded">Toggle</button> <p x-show="expanded" x-collapse>Content</p> </div> @astrojs/cloudflare adapter enables deploying to Cloudflare. Includes: imageService: 'passthrough'|'cloudflare'|'compile'|'custom', platformProxy, routes.extend, cloudflareModules. Access Cloudflare bindings via Astro.locals.runtime. Use _headers, _redirects, and _routes.json for Cloudflare configuration. Supports WASM, .bin, and .txt module imports. Supports some Node.js APIs with node:* import syntax and vite config changes. Astro DB: Fully-managed SQL database. Installation: `npx astro add db`. `db/config.ts`: configures tables. `defineDb({ tables: {} })`. `defineTable`: defines tables and columns. `column`: `column.text(...)`, `column.number(...)`, `column.boolean(...)`, `column.date(...)`, `column.json(...)`. `primaryKey`, `optional`, `default`, `unique`, `references`. `indexes`: `{ on: string | string[], unique: boolean, name: string? }`. `foreignKeys`: `{columns: string[], references: () => Column[]}`. CLI: `astro db push`, `astro db verify`, `astro db execute [--remote]`, `astro db shell --query [--remote]`. `isDbError(e)`: checks for libSQL database exceptions. Example: `await db.insert(Comment).values({ ... });` Handle DB errors with try/catch and `isDbError(e)`. Integrations: `@astrojs/alpinejs`, `@astrojs/lit`, `@astrojs/preact`, `@astrojs/react`, `@astrojs/solid-js`, `@astrojs/svelte`, `@astrojs/vue`, `@astrojs/cloudflare`, `@astrojs/netlify`, `@astrojs/node`, `@astrojs/vercel`, `@astrojs/db`, `@astrojs/markdoc`, `@astrojs/mdx`, `@astrojs/partytown`, `@astrojs/sitemap`, `@astrojs/tailwind`. Integrations add functionality to Astro projects. Types: UI frameworks renderers SSR adapters tools features custom code hooks. Integrations directory: browse official and community integrations. Official Integrations: UI Frameworks @astrojs/alpinejs @astrojs/lit @astrojs/preact @astrojs/react @astrojs/solid-js @astrojs/svelte @astrojs/vue SSR Adapters @astrojs/cloudflare @astrojs/netlify @astrojs/node @astrojs/vercel Other @astrojs/db @astrojs/markdoc @astrojs/mdx @astrojs/partytown @astrojs/sitemap @astrojs/tailwind. Automatic setup: astro add command (npx astro add [integration]). Manual install: integrations property in astro.config.mjs. Import integration: npm package local file inline object. defineConfig({ integrations: [...] }). Custom options via factory functions. Toggle integrations: falsy integrations ignored. Upgrade all: @astrojs/upgrade. Upgrade manual: npm/pnpm/yarn install @astrojs/[integration]@latest. Remove: npm/pnpm/yarn uninstall and remove from astro.config.mjs. Integration API inspired by Rollup/Vite. @astrojs/lit: Enables SSR and client-side hydration for Lit custom elements. Installation: `npx astro add lit` or manual install. Manual Install: `npm install @astrojs/lit`, add to `astro.config.mjs`: `integrations: [lit()]`. Requires: `lit` and `@webcomponents/template-shadowroot`. Usage: Import Lit components in Astro frontmatter. Experimental Decorators: Set `"experimentalDecorators": true` in `tsconfig.json`. Polyfills & Hydration: Automatic polyfills and hydration using `client:` directives. Troubleshooting: Browser globals can interfere with other libraries. Change integration order. Strict package managers: Hoist Lit dependencies with `.npmrc`: `public-hoist-pattern[]=*lit*`. Limitations: Powered by `@lit-labs/ssr`. No IntelliSense. Example: src/components/my-element.js: ```js import { LitElement, html } from 'lit'; export class MyElement extends LitElement { render() { return html`Hello world!`; } } customElements.define('my-element', MyElement); ``` @astrojs/markdoc: Enables Markdoc for components, pages, content collections. Installation: `npx astro add markdoc` or manual install. Manual Install: `npm install @astrojs/markdoc`, then add to `astro.config.mjs`: `integrations: [markdoc()]`. VS Code Integration: Configure `markdoc.config.json` for syntax highlighting. Usage: Use .mdoc files in content collections. Query with Content Collection APIs. Pass Markdoc variables: Pass props to Content component. Global variables in `markdoc.config.mjs`. Access frontmatter: Pass `entry.data` as `frontmatter` prop to `Content`. Render components: Configure tags in `markdoc.config.mjs` to map to .astro components. Use client-side UI components: Wrap with .astro component using `client:` directive. Use Astro components from npm: Use `component()` with import name. Markdoc Partials: `{% partial %}` tag renders other .mdoc files. Syntax highlighting: Use `shiki()` or `prism()` extensions. Custom Markdoc nodes/elements: Configure nodes in `markdoc.config.mjs`. Custom headings: Apply Astro component as Markdoc node for headings. Props: `level`, `id`. Custom image components: Override default image node or create custom tag. Advanced Markdoc configuration: Use `markdoc.config.mjs` for tags, functions. Set root HTML element: Configure `document` node in `markdoc.config.mjs`. Integration config options: allowHTML: Enables HTML markup. Caution: XSS risk. ignoreIndentation: Supports arbitrary indentation. Example: markdoc.config.mjs: ```js import { defineMarkdocConfig } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ variables: { environment: process.env.IS_PROD ? 'prod' : 'dev' }, }); ``` @astrojs/mdx: Enables MDX components. Install: npm/pnpm/yarn astro add mdx. Configuration: extends Markdown config, remarkPlugins, rehypePlugins, recmaPlugins, optimize. optimize: {ignoreElementNames?: string[]}. MDX does not support passing remark/rehype plugins as a string. Module @astrojs/netlify: Adapter to deploy Astro to Netlify. Install: astro add netlify. defineConfig: adapter: netlify({edgeMiddleware: bool, imageCDN: bool}). Astro.locals.netlify.context: Access Edge Functions context. edgeMiddleware: true - middleware on Edge Functions. imageCDN: false - disable Netlify Image CDN. redirects config for static sites. cacheOnDemandPages: true - cache server pages. Module @astrojs/node: Adapter to deploy Astro to Node.js. Install: astro add node. defineConfig: adapter: node({mode: 'middleware'|'standalone'}). Middleware mode: handler in ./dist/server/entry.mjs. Standalone mode: run ./dist/server/entry.mjs. Env vars: HOST, PORT, SERVER_CERT_PATH, SERVER_KEY_PATH. @astrojs/partytown: Astro integration enables Partytown for off-main-thread scripts. Install: `npx astro add partytown`. Manual install: `npm install @astrojs/partytown`. Usage: ` @astrojs/preact integrates Preact components. Supports server-side rendering and client-side hydration. `preact({ compat: true })`: Enables preact/compat for React component rendering. `devtools: true`: Enables Preact devtools in development. `include`, `exclude`: Configure which files belong to which framework when using multiple JSX frameworks. @astrojs/react: Astro integration for React components. Enables server-side rendering and client-side hydration. Install: astro add react, npm install react react-dom, add integration to astro.config.mjs. Options: include, exclude for JSX frameworks, experimentalReactChildren for React virtual DOM nodes as children. @astrojs/sitemap: Generates sitemap.xml based on pages. Install: npm install @astrojs/sitemap. Add to astro.config.mjs: integrations: [sitemap()]. Config: site: 'https://example.com'. Options: filter: (page: string) => boolean, customPages: string[], entryLimit: number, changefreq: string, lastmod: Date, priority: number, serialize: (item: SitemapItem) => SitemapItem | undefined, i18n: { defaultLocale: string, locales: Record }. Sitemap discovery: link rel="sitemap" in , robots.txt entry. Example: sitemap({ site: 'https://stargazers.club', filter: (page) => page !== 'https://stargazers.club/secret-vip-lounge/', }) @astrojs/solid-js: Enables server-side rendering and client-side hydration for SolidJS components. Installation: `npx astro add solid` Manual Install: `npm install @astrojs/solid-js solid-js` astro.config.mjs: `import solid from '@astrojs/solid-js';` `integrations: [solid()]` Configuration: `solid({ devtools: true })` Enable Solid DevTools during development. Requires `npm install solid-devtools`. `solid({ include: ['**/solid/*'] })` Specify Solid files when using multiple JSX frameworks. Usage: Use SolidJS components like other UI framework components. Suspense Boundaries: Server and hydrating components are wrapped in Suspense; async data fetched using `createResource` is included in initial HTML. Non-hydrating `client:only` components are not. @astrojs/svelte: Integrates Svelte components. Install: npx astro add svelte. Customize with options to the svelte integration. Required options: emitCss, compilerOptions.dev, compilerOptions.hydratable. svelte.config.js allows IDE support for preprocessors. @astrojs/tailwind integration for Tailwind CSS. Install: npx astro add tailwind. Configuration: tailwind.config.mjs. Options: configFile, applyBaseStyles, nesting. @astrojs/vercel: Adapter for deploying Astro to Vercel (hybrid/SSR). Installation: `npx astro add vercel`. Configuration: vercel(config). Targets: serverless, static. config: - webAnalytics: { enabled: boolean } Enable Vercel Web Analytics. - imagesConfig: { sizes: number[] } Vercel Image Optimization API configuration. - imageService: boolean Enable Vercel Image Optimization API. devImageService: 'sharp' | 'squoosh' | string Development image service. - isr: boolean | {bypassToken:string, exclude: string[], expiration: number} Enable Incremental Static Regeneration. expiration: cache time in seconds. exclude: paths not to cache. - includeFiles: string[] Files to bundle. - excludeFiles: string[] Files to exclude. - maxDuration: number Max function duration (seconds). - skewProtection: boolean Enable Vercel Skew protection. - functionPerRoute: boolean Separate function per route. - edgeMiddleware: boolean Create edge function from Astro middleware. EdgeLocals type available for TypeScript. @astrojs/vue integration enables Vue 3 components. Options include: template compilerOptions, appEntrypoint, jsx, and devtools. Customizes Vue compiler via @vitejs/plugin-vue. Internationalization (i18n): Configure defaultLocale and locales in astro.config.mjs. Supports prefixDefaultLocale (boolean), redirectToDefaultLocale (boolean), and manual routing ("manual"). routing: {domains} for custom domains. fallback: {locale: fallbackLocale}. Custom locale paths. Astro.preferredLocale, Astro.preferredLocaleList, Astro.currentLocale for browser language detection. Limitations: site, output: server, no prerendered pages, and adapter feature functionPerRoute not supported. Requires X-Forwarded-Host, Host, X-Forwarded-Proto headers. Markdown & MDX: Astro supports Markdown and MDX files, including frontmatter. Files in /src/pages/ create pages. Frontmatter: layout, properties available through Astro.props. MDX supports JSX, components, and export statements. Import Markdown/MDX with import or Astro.glob(). Properties: file, url, frontmatter, getHeadings(), Content, rawContent(), compiledContent(). Dynamic routing uses getStaticPaths(). Custom components via components prop. Markdown configuration via astro.config.mjs, remark and rehype plugins. Syntax highlighting with Shiki (default) or Prism. Remote Markdown requires external parsing, e.g., marked. Middleware: Intercept requests/responses. `src/middleware.js|ts` export `onRequest(context, next)`. `context.locals` shares data. Example: `export function onRequest (context, next) { context.locals.title = "New title"; return next(); }`. Access: `Astro.locals`. `defineMiddleware()` for types. `MiddlewareHandler` JSDoc type. Type `Astro.locals`: `namespace App { interface Locals { ... } }` in `env.d.ts`. `sequence(...middlewares)` chains. `context.rewrite(Request)` rewrites & re-executes middleware. `next(Request)` rewrites, no re-execution. Runs for 404/500 pages, adapter dependent. Migrating from Create React App (CRA): Astro's React integration supports React components. Use client:load directive. Use .astro and .jsx components. Add React integration and dependencies, copy CRA files. Rename .js to .jsx/.tsx. Use astro.config.mjs. Import root component and render. Use client directives for interactivity. JSX and Astro component comparison. Use fetch() for data fetching. Migrating from Docusaurus: Both Astro and Docusaurus are modern, JavaScript-based site builders. Astro supports MDX, uses file-based routing, has React integration. Astro uses Markdown files by default, Starlight theme. Astro supports components from JS frameworks, but uses Astro layouts for templating. Astro uses src/ for all files and public/ for static assets. Bundling CSS, JavaScript, and assets is handled automatically. Gatsby to Astro migration guide. Key differences: Gatsby SPA, Astro multi-page. Data: Gatsby GraphQL, Astro ESM imports/glob. Convert: create astro, move files to src, JSX to .astro, children to <slot/>, links to <a>, images to Astro Image/<img>, GraphQL to glob. Config: gatsby-config.js to siteMetadata.js, gatsby-browser.js to layout <head>. Layout: <slot/>, direct <head>. Pages/Posts in src/pages. No gatsby-*.js config. Community resources. Migrating from GitBook: Astro supports Markdown, uses file-based routing. Use Starlight docs theme. GitBook content can be synced to Astro project with Git Sync feature. Requires manual syntax changes for Astro compatibility. .mdoc extension required. GitBook closing tag changes to end. Gridsome to Astro migration. Similarities: project structure src/, src/pages/, routing. Differences: Gridsome Vue SPA, Astro multi-page. Data: Gridsome GraphQL, Astro ESM imports/glob. Convert: create astro --template blog, copy files, use Astro.glob for data. Vue components reusable. Community resources. Migrating from Hugo to Astro: Similarities: static-site generators, Markdown content, integrations. Differences: Go Templating vs JSX-like syntax, no shortcodes (use MDX), component-based vs partials. Steps: Use blog theme starter, convert frontmatter to YAML, use MDX for dynamic content. Other starters available on astro.new. Migrating from Jekyll. Astro is static-site generator using Markdown and HTML. Astro uses JSX-like .astro files for templating. Switch to Astro blog theme, convert HTML to Astro pages. Astro has a special src/pages/ directory. Astro does not have a permalink property. Migrating from Next.js. Astro uses .astro files, file-based routing, component-based architecture. Convert JSX to .astro, Next.js components to Astro components. Use Astro.props, import statements, or Astro.glob() instead of getStaticProps(). Example: Blog becomes Blog; {children} becomes . Migrate from NuxtJS: Guide for migrating from Nuxt 2 to Astro. Similarities: SSG/SSR, file-based routing, component-based, Vue support, NPM package support. Differences: Nuxt is Vue SPA, Astro is MPA with .astro components and supports multiple frameworks. Create Astro project: npm create astro@latest -- --template [example-name] Move static assets: static/ to public/. Move source code to src/: pages, layouts, components, styles, scripts. Convert Vue SFC to .astro: Template to HTML, script to code fence (---). Vue vs Astro: Convert Vue syntax to Astro syntax. Migrate Layout Files: Astro pages require <html>, <head>, <body>. Migrate Pages and Posts: Vue pages to .astro pages in src/pages/. Dynamic File Path Naming: _name.vue to [name].astro. Markdown/MDX: Place in src/pages/ or src/content/. Testing: Write end-to-end tests. Reference: Local Variables: {{message}} to {message}. Property Passing: v-bind:aria-label to aria-label={message}. Links: <NuxtLink to=""> to <a href="">. Imports: Update file paths. Dynamic Page Generation: getStaticPaths() for static routes. Data Fetching: Fetch data inside code fence. Styling: <style> for scoped styles, is:global for global styles. Image Plugin: <nuxt-img/> to <Image /> in .astro, <img/> in Vue. Example: Nuxt Pokédex to Astro using fetch(). Migrating from Pelican. Pelican is a Python static site generator. Astro supports Markdown and MDX, Pelican supports reStructuredText. Astro uses JSX-like syntax, Pelican uses Jinja. Migrating from SvelteKit: Astro is multi-page apps; SvelteKit defaults to SPAs. Astro pages use .astro components. Markdown-ready: Astro includes built-in Markdown support. Use npm/pnpm/yarn create astro --template blog to convert SvelteKit blog to Astro. Migrating from VuePress. VuePress is a static site generator built on Vue. Astro: Multi-page apps using .astro components, supporting React, Vue, Svelte, etc. Layouts: VuePress uses .md & .html. Astro uses Astro components and .md/.mdx with layouts. Migrating from WordPress: WordPress similarities: content-driven, Markdown support, "block" design. Differences: code editor vs dashboard, less plugins, file-based content vs database. Migrate: use blog theme starter. Option: keep WordPress as CMS. Export content: tool for exporting Markdown from WordPress. Migrate existing projects to Astro. Astro supports UI framework components, CSS stylesheets, and Markdown/MDX files. Suitable for content-based sites (blogs, landing pages, etc.). prefetch config: prefetch: true enables prefetching. data-astro-prefetch attribute to opt-in. Strategies: hover (default), tap, viewport, load. prefetch({defaultStrategy: 'viewport'}). prefetchAll: true prefetches all links. prefetch(url, {ignoreSlowConnection: true}). Browser support: <link rel="prefetch">, fetch() API. File-based routing in src/pages/. Static routes from .astro, .md, .mdx files. Dynamic routes use [param]. getStaticPaths() required for static dynamic routes, returns [{params: {param: value}}]. Astro.params accesses route parameters. Rest parameters [...path] match any path depth. SSR mode for dynamic routes does not use getStaticPaths(). Astro.redirect(path) for redirects. Astro.rewrite(path) serves different route content without redirect. Route priority: more segments, static > dynamic, named > rest, pre-rendered > server, endpoints > pages, file-based > redirects. Pagination for large data sets using paginate(data, {pageSize}). Paginated routes use [page]. Page prop contains page data, urls (next, prev). Nested pagination groups paginated data by property, use array of paginate() results in getStaticPaths(). Exclude pages/dirs with _ prefix. Testing: Use testing frameworks to assert code behavior. Vitest: Vite-native unit test framework. Requires vitest.config.ts. getViteConfig(options, astroConfig): Configures Vitest with Astro settings. Container API: Test Astro components. AstroContainer.create(): Creates container. container.renderToString(Card, {slots}): Renders component to string. Playwright: End-to-end testing. Test on Chromium, WebKit, Firefox. npx playwright test [file]: Runs tests. npx playwright show-report: Shows HTML test report. webServer: {command, url, timeout, reuseExistingServer}: Starts dev server during tests. Cypress: Front-end testing tool. npx cypress run: Runs tests from command line. npx cypress open: Opens Cypress App. NightwatchJS: Test automation framework. npx nightwatch [file]: Runs tests. npx nightwatch [file] -e [browser]: Runs tests against a browser. npx nightwatch [file] --open: Opens HTML Test Report. Troubleshooting guide. `console.log()`: Debug output. ``: Astro component to output values directly to the HTML template. Common errors: "Cannot use import statement outside a module" (add type="module" to ` Astro Upgrade Guide: v0.x to v1.0. Update Astro version via package manager. Astro v1.0: Vite upgraded to v3. Astro.canonicalURL deprecated, use Astro.url. Scoped CSS specificity now preserved. Components/JSX in Markdown deprecated, use @astrojs/mdx. <Markdown /> component moved to @astrojs/markdown-component. Migrate to v0.26: Configuration API redesigned. .buildOptions.site replaced by .site and .base. .markdownOptions replaced by .markdown. .sitemap moved to @astrojs/sitemap. Markdown API updated: Astro.fetchContent() replaced by Astro.glob(). Markdown objects use .frontmatter. <script> tags are built/bundled by default. <script hoist> is default. Use <script is:inline> to revert. Astro.request changed to standard Request object. Astro.request.params to Astro.params. Astro.request.canonicalURL to Astro.canonicalURL. Migrate to v0.25: Integrations replace renderers. Built-in framework support removed. Install frameworks as integrations (e.g. @astrojs/react). Integrations don't mark frameworks as direct dependencies. Updated Syntax Highlighting: Shiki is default. Migrate to v0.24: New static build strategy. Astro.resolve() deprecated, use ESM imports or absolute URL paths. <script> elements require hoist attribute for processing. Migrate to v0.23: Sass is optional dependency (npm install sass). Unescaped HTML in expressions deprecated, use set:html or set:text. Migrate to v0.21: Built with Vite. Move snowpack.config.mjs to astro.config.mjs. Configure Vite plugins in astro.config.mjs. File extensions in imports must be exact. Components in Frontmatter removed. Autoprefixer and Tailwind CSS need postcss.config.cjs. Imports must be at top of frontmatter. <ViewTransitions />: Enables animated page transitions. Add to <head>. SPA mode: site-wide transitions. Transition Directives: transition:name (match elements), transition:animate (animation type), transition:persist (persist components). transition:persist-props (persist props) <aside transition:name="hero">. Built-in animations: fade, slide, none. Custom animations: TransitionAnimation, TransitionAnimationPair. Router control: data-astro-reload (full-page navigation), navigate(href, options). Events: astro:before-preparation, astro:after-preparation, astro:before-swap, astro:after-swap, astro:page-load. Accessibility: Route announcement, prefers-reduced-motion. Install and set up Astro: `npm create astro@latest`: Starts a new Astro project. Prerequisites: Node.js (v18.17.1, v20.3.0+), VS Code (recommended). `npm create astro@latest -- --template `: Use an official template. `npm create astro@latest -- --template /`: Use a GitHub repo template. Edit: Modify files in your code editor. `npm run dev`: Start the development server (http://localhost:4321/). `npm run build`: Build a deployable version in /dist. `npm run preview`: Preview the built version locally. Manual Setup: `mkdir my-astro-project; cd my-astro-project` `npm init --yes` `npm install astro` package.json scripts: `"dev": "astro dev", "build": "astro build", "preview": "astro preview"` Create `src/pages/index.astro` with HTML content. Create `public/robots.txt`. Create `astro.config.mjs`: `import { defineConfig } from 'astro/config'; export default defineConfig({});` Create `tsconfig.json`: `{ "extends": "astro/tsconfigs/base" }` Install @rollup/plugin-yaml. Import and add yaml() to vite plugins. Import YAML data using an import statement. getImage({src, format, width, height}): Creates custom image components. Props: mobileImgUrl, desktopImgUrl, alt. POST API endpoint (/api/feedback): Handles form data via request.formData(), validates data, & returns JSON. FeedbackForm component: Creates a form with input fields (name, email, message) & a submit button. onSubmit: e.preventDefault() to prevent default submission. FormData object is created from the form & sent to the endpoint using fetch(). Build HTML forms in Astro pages. Use Astro.request.formData(). Bun: JavaScript runtime & toolkit. Use with caution, some integrations may not work. bunx create-astro@latest [project]: Creates new Astro project. bun install: Installs dependencies. bun add -d @types/bun: Adds Bun types. bunx astro add [integration]: Adds Astro integration. bunx --bun astro dev: Runs development server. bunx --bun astro build: Builds site. Output to dist/. bunx --bun astro preview: Serves built site. bun test: Runs tests. bun add cypress --dev: Installs Cypress. bun create playwright: Installs Playwright. Call server endpoints from a page's component script. GET(Astro) -> Response. Example: const data = await response.json(). API Route to verify Google reCAPTCHA v3. POST endpoint: accepts recaptcha data, verifies with reCAPTCHA API. Example: src/pages/recaptcha.js export async function POST({ request }) { const data = await request.json(); ... return new Response(JSON.stringify(responseData), { status: 200 }); } Client script: fetch("/recaptcha", { method: "POST", body: JSON.stringify({ recaptcha: token }) }).then((response) => response.json()).then((gResponse) => { if (gResponse.success) { // Success } else { // Failed } }) Dockerfile: Instructions to build site. FROM, WORKDIR, COPY, RUN, ENV, EXPOSE, CMD. .dockerignore: Files/folders to ignore. Build: docker build -t <your-astro-image-name> . Run: docker run -p <local-port>:<container-port> <your-astro-image-name> Dynamically import images. Use import.meta.glob to import images. Example: const images = import.meta.glob<{ default: ImageMetadata }>(\'/src/assets/*.{jpeg,jpg,png,gif}\') Install rehype-external-links. Configure rehypeExternalLinks with content to add icons to external links. Implement i18n using content collections and dynamic routing. Create language directories (e.g., /en/, /fr/). Redirect to default language. Use getStaticPaths or getEntry for dynamic routes. Use toLocaleString() for date formatting. Translate UI strings with dictionaries. Use getLangFromUrl, useTranslations, useTranslatedPath and getRouteFromUrl to implement i18n. Dev Toolbar Apps: Extend toolbar. Integration & app needed. Integration: `my-integration.ts`: `addDevToolbarApp({ id, name, icon, entrypoint })` in `astro:config:setup` hook. Add to `astro.config.mjs`: `integrations: [myIntegration]`. App: `app.ts`: `defineToolbarApp({ init(canvas, app, server) { ... } })`. `canvas`: ShadowRoot. `app.onToggled({ state })`: interactivity. UI frameworks: React, Vue, Svelte. No build: Preact `h`, `htm/preact`. Build: TypeScript, tsconfig.json, `tsc` compile. Add last modified time to Markdown/MDX files. Install Day.js: npm install dayjs. Remark plugin (remark-modified-time.mjs): uses execSync to get git log timestamp or statSync to get mtime. Add plugin to astro.config.mjs: markdown: { remarkPlugins: [remarkModifiedTime] }. Display lastModified: access remarkPluginFrontmatter from entry.render(). Example plugin (Git): import { execSync } from "child_process"; export function remarkModifiedTime() { return function (tree, file) { const filepath = file.history[0]; const result = execSync(`git log -1 --pretty="format:%cI" "${filepath}"`); file.data.astro.frontmatter.lastModified = result.toString(); }; } remarkReadingTime plugin calculates reading time for Markdown/MDX files. remarkReadingTime(tree, {data}) -> modifies frontmatter.minutesRead. Share state between Astro components using Nano Stores. Example: src/store.js: `isOpen = atom(false)`. Use `isOpen.set()` and `isOpen.subscribe()` in components. Share state between Islands: Use Nano Stores for shared client-side storage. Lightweight, framework-agnostic. Install: `npm install nanostores @nanostores/[framework]` Usage: 1. Create a store (e.g., `src/cartStore.js`): `import { atom } from 'nanostores'; export const isCartOpen = atom(false);` 2. Import and use the store in components: Preact/React/Solid/Vue: `import { useStore } from '@nanostores/[framework]';` Svelte: Use `$` prefix for store value. Lit: Use `StoreController`. `atom(initialValue)`: Creates a store with an initial value. Use `.set(newValue)` to update. `map(initialValue)`: Creates a store for objects. Use `.setKey(key, newValue)` to update specific keys. Example: `import { atom, map } from 'nanostores';` `export const isCartOpen = atom(false);` `export const cartItems = map({});` `cartItems.setKey(id, { id, name, imageSrc, quantity: 1 });` `import { useStore } from '@nanostores/react';` `const $isCartOpen = useStore(isCartOpen);` Caveats: - Writing to a store from a .astro file won't affect client-side components. - Cannot pass Nano Stores as props to client-side components. - Cannot subscribe to store changes from a .astro file (no re-renders). Improve page performance by moving fetch calls to smaller components. Promises: const personPromise = fetch(...).then(...) Style Markdown with Tailwind Typography: Use @tailwindcss/typography plugin. Install: npm install -D @tailwindcss/typography. Add plugin to tailwind.config.js. Create <Prose /> component with <slot /> and class="prose dark:prose-invert ...". Wrap <Content /> from content collection entry with <Prose />. Astro Adapter API. An adapter is a special kind of integration that provides an entrypoint for server-side rendering. interface AstroAdapter { name: string; serverEntrypoint?: string; previewEntrypoint?: string; exports?: string[]; args?: any; adapterFeatures?: AstroAdapterFeatures; supportedAstroFeatures?: AstroFeatureMap; } interface AstroAdapterFeatures { edgeMiddleware: boolean; functionPerRoute: boolean; } type SupportsKind = 'unsupported' | 'stable' | 'experimental' | 'deprecated'; type AstroFeatureMap = { staticOutput?: SupportsKind; hybridOutput?: SupportsKind; serverOutput?: SupportsKind; assets?: AstroAssetsFeature; }; interface AstroAssetsFeature { supportKind?: SupportsKind; isSharpCompatible?: boolean; isSquooshCompatible?: boolean; } App: app.render(request: Request, options?: RenderOptions). RenderOptions: addCookieHeader: boolean, clientAddress, locals, routeData. app.match(request): Returns boolean Astro Global: Astro.glob(glob): load local files, returns array. Astro.props: component props. Astro.params: route params. Astro.request: Request object. Astro.response: ResponseInit object. Astro.cookies: get(key, opts?), has(key, opts?), set(key, val, opts?), delete(key, opts?), merge(cookies), headers(). AstroCookie: value, json(), number(), boolean(). AstroCookieGetOptions: decode(val). AstroCookieSetOptions: domain, expires, httpOnly, maxAge, path, sameSite, secure, encode(val). Astro.redirect(path, status?). Astro.rewrite(payload). Astro.url: URL object. Astro.clientAddress: client IP (SSR). Astro.site: site URL. Astro.generator: Astro version. Astro.slots: has(slotName), render(slotName, args?). Astro.self: recursive component. Astro.locals: middleware locals. Astro.preferredLocale/List/currentLocale: i18n locales (SSR). APIContext: context.params/props/request/cookies/url/clientAddress/site/generator/redirect/rewrite/locals. getStaticPaths(): dynamic routes, returns [{params, props?}]. paginate(data, {pageSize, params, props}): pagination for getStaticPaths. page prop: page.data, page.start/end/size/total/currentPage/lastPage, page.url.current/prev/next/first/last. import.meta.env.SSR: SSR check. astro:assets: getImage(options): optimize image, returns GetImageResult. astro:content: defineCollection({type:'content'|'data', schema}), reference(collection), getCollection(collection, filter?), getEntry(collection, slugOrId), getEntries(entries), CollectionEntry:{id, collection, data, slug?, body?, render()}. astro:middleware: onRequest(context, next), next(rewritePayload?), sequence(...handlers). astro:i18n: getRelativeLocaleUrl(locale, path?, opts?), getAbsoluteLocaleUrl(locale, path, opts?), getRelativeLocaleUrlList(path?, opts?), getAbsoluteLocaleUrlList(path?, opts?), getPathByLocale(locale), getLocaleByPath(path), redirectToDefaultLocale(context, status?), redirectToFallback(context, response), notFound(context, response?), middleware({prefixDefaultLocale, redirectToDefaultLocale}), requestHasLocale(context). astro:components: , , , , , , , . CLI commands: add: Add integration. build: Builds project. check: Checks for errors. dev: Starts dev server. docs: Opens documentation. info: Lists info. preview: Previews build. sync: Generates TypeScript types. preferences: Configures user preferences. telemetry: Configures telemetry settings. Global flags: --config , --root , --site , --base , --verbose, --silent, --version, --open, --help. astro dev: Starts dev server. astro build: Builds site. astro preview: Starts local server for static directory. astro check: Runs diagnostics. Flags: --watch, --root, --tsconfig, --minimumFailingSeverity, --minimumSeverity, --preserveWatchOutput, --noSync. astro sync: Generates TypeScript types. astro add: Adds integration. astro docs: Opens docs. astro info: Shows environment info. astro preferences: Manages user preferences. astro telemetry: Sets telemetry config. Common flags: --root, --config, --outDir, --site, --base, --port, --host, --verbose, --silent. Advanced APIs: AstroInlineConfig extends AstroUserConfig; dev(inlineConfig: AstroInlineConfig) => AstroDevServer; build(inlineConfig: AstroInlineConfig) => void; preview(inlineConfig: AstroInlineConfig) => AstroPreviewServer; sync(inlineConfig: AstroInlineConfig) => number. Astro Studio CLI: astro login, astro link, astro logout. Configuration Reference for Astro. Includes options for site, base, trailingSlash, redirects, output, adapter, integrations, root, srcDir, publicDir, outDir, cacheDir, compressHTML, scopedStyleStrategy, security, vite, build, server, prefetch, image, markdown, i18n, and experimental features. Experimental Container API. Render Astro components in isolation. API subject to breaking changes. experimental_AstroContainer.create(options?: AstroContainerOptions): Promise. AstroContainerOptions: {streaming?: boolean, renderers?: AddServerRenderer[]}. AddServerRenderer: {renderer: NamedSSRLoadedRendererValue} | {renderer: SSRLoadedRendererValue, name: string}. streaming: enable HTML streaming. renderers: array of client renderers. getContainerRenderer() helpers for @astrojs/react, preact, solid-js, svelte, vue, lit, mdx. loadRenderers(renderers: SSRLoadedRendererValue[]): Promise. container.addServerRenderer({renderer}). container.addClientRenderer({name, entrypoint}). container.renderToString(component: AstroComponent, options?: ContainerRenderOptions): Promise. container.renderToResponse(component: AstroComponent, options?: ContainerRenderOptions): Promise. ContainerRenderOptions: {slots?: Record, props?: Record, request?: Request, params?: Record, locals?: App.Locals, routeType?: "page" | "endpoint"}. slots: content for . props: properties for Astro components. request: Request object for Astro.url, Astro.request. params: path parameters for dynamic routes (Astro.params). locals: Astro.locals. routeType: "page" or "endpoint" for renderToResponse. Dev Toolbar App API: Allows creating integrations with the Dev Toolbar. Integrations setup in `astro:config:setup` hook. `addDevToolbarApp({id, name, icon, entrypoint})`. `defineToolbarApp`: defines app logic. `init(canvas: ShadowRoot, app: ToolbarAppEventTarget, server: ToolbarServerHelpers)`: initializes the app. `beforeTogglingOff(canvas: ShadowRoot): boolean | void`: runs before app toggles off. `app.onToggled(callback: (options: {state: boolean}))`: toggles app on/off. `app.onToolbarPlacementUpdated(callback: (options: {placement: 'bottom-left' | 'bottom-center' | 'bottom-right'}))`: toolbar placement update. `app.toggleState(options: {state: boolean})`: changes app state. `app.toggleNotification(options: {state?: boolean, level?: 'error' | 'warning' | 'info'})`: toggles app notification. `server.send(event: string, data: T)`: sends data to server. `server.on(event: string, callback: (data: T) => void)`: receives data from server. Server-side: `toolbar.send(event: string, data: T)`: sends data to client. `toolbar.on(event: string, callback: (data: T) => void)`: receives data from client. `toolbar.onInitialized(appId: string, callback: () => void)`: when app is initialized. `toolbar.onAppToggled(appId: string, callback: (options: {state: boolean}) => void)`: when app toggles. Components: `astro-dev-toolbar-window`, `astro-dev-toolbar-button`, `astro-dev-toolbar-badge`, `astro-dev-toolbar-card`, `astro-dev-toolbar-toggle`, `astro-dev-toolbar-radio-checkbox`, `astro-dev-toolbar-highlight`, `astro-dev-toolbar-tooltip`, `astro-dev-toolbar-icon`. Template Directives: Special HTML attributes in .astro components. class:list={array}: Converts array of class values to class string. Example: <span class:list={['hello', { world: true }]} /> set:html={string}: Injects HTML string. Unescaped. Use with caution (XSS). set:text={string}: Injects text string. Automatically escaped. Client Directives: Control UI framework component hydration. client:load: Hydrate immediately on page load. client:idle: Hydrate after initial load (requestIdleCallback). client:visible: Hydrate when in viewport (IntersectionObserver). client:visible={{rootMargin}}: Hydrate when within rootMargin of viewport. client:media={string}: Hydrate when CSS media query is met. client:only={framework}: Skips server rendering, renders only on client. Framework required. Script & Style Directives: is:global: Style tag applies globally. is:inline: Leaves script/style tag as-is. No processing. define:vars={...}: Pass server-side variables to client script/style (JSON serializable). Implies is:inline for scripts. Advanced Directives: is:raw: Treats element children as text. Ignores Astro syntax. Action called from a server page or endpoint without `Astro.callAction()`. ActionQueryStringInvalidError: Invalid query string. Action name not found. Remove query param and refresh. ActionsUsedWithForGetError: Action called from form with GET request; only POST supported. Ensure method="POST" is on the form. ActionsWithoutServerOutputError: Actions require server output. Add server adapter to astro config. AstroGlobNoMatch: Astro.glob(GLOB_STR) no matching files. Check glob pattern. Astro.glob(GLOB_STR): Can only be used in .astro files. Use import.meta.glob(GLOB_STR) instead. AstroResponseHeadersReassigned: Astro.response.headers must not be reassigned. Individual headers can be added to and removed from Astro.response.headers, but it must not be replaced with another instance of Headers altogether. CantRenderPage: Astro cannot find content to render for route. ClientAddressNotAvailable: Astro.clientAddress not available in current adapter. Adapter needs support. Collection does not exist: Querying a non-existent collection no longer errors, but warns. ConfigLegacyKey: Legacy configuration detected. ConfigNotFound: Check the --config file path; file not found. ContentCollectionTypeMismatchError: Collection type mismatch. Content collections require entries of the configured type. Use type: 'data' for data collections. ContentSchemaContainsSlugError: Remove 'slug' field from collection schema; reserved for slug generation. CouldNotTransformImage: Error when Astro can't transform an image. May be caused by a corrupted image. Re-exporting image may fix it. CSSSyntaxError: Error parsing CSS (e.g., Missed semicolon, Unclosed string). Check CSS syntax. Data collection entry failed to parse: 'data' entries must return valid JSON (.json) or YAML (.yaml). Duplicate content entry slug. COLLECTION_NAME has entries with same slug: SLUG. Slugs must be unique. EndpointDidNotReturnAResponse: Endpoint must return Response or Promise resolving with Response. Example: export async function GET({request, url, cookies}: APIContext): Promise<Response> { return Response.json({ success: true, result: 'Data' }) } EnvInvalidVariablesError: Invalid environment variables defined in experimental.env.schema. Some variables do not match schema data type/properties. EnvUnsupportedGetSecret: astro:env/server.getSecret() is not supported by the adapter. ExpectedImage: getImage or <Image /> src must be ESM imported image or remote image string. Example: <Image src={myImage} alt="..." /> or <Image src="https://example.com/logo.png" ... /> Expected image options: getImage() parameter must be an object. getImage({src, width, height}): Optimizes image. Example: const optimizedImage = await getImage({src: myImage, width: 300, height: 300}); ExpectedNotESMImage: Pass image object with `src` property to `getImage()`, not ESM-imported image directly. Example: `getImage({ src: myImage })` Error Failed to retrieve remote image dimensions: Cannot get dimensions for IMAGE_URL. Caused by incorrect URL or public folder image. FailedToFindPageMapSSR: Astro couldn’t find the correct page for SSR. Internal error. FailedToLoadModuleSSR: Could not import IMPORT_NAME. Check import path or if type import is specified. GenerateContentTypesError: astro sync command failed to generate content collection types. getDataEntryById or getEntryBySlug is deprecated. Use getEntry instead. getStaticPaths(): Requires a 'params' property specifying path parameters. GetStaticPathsInvalidRouteParam: Invalid getStaticPaths route parameter. params: undefined, string, number. /route/[...id].astro: undefined for no parameters. GetStaticPathsRemovedRSSHelper: RSS helper removed from getStaticPaths. Use @astrojs/rss. Error GetStaticPathsRequired: dynamic routes in static mode require getStaticPaths() function export. i18nNoLocaleFoundInPath: Error when using an i18n utility on a path without a locale. Use pathHasLocale to check URLs first. i18nNotEnabled: astro:i18n can't be used without i18n enabled in Astro config. Enable with defaultLocale and locales. ImageMissingAlt: Image component requires an "alt" property for accessibility. Set alt="" for decorative images. ImageNotFound: Astro could not find requested image. IncompatibleDescriptorOptions: Error when both densities and widths are set. Only one can be specified. For srcset, use widths. IncorrectStrategyForI18n: Error. Function requires i18n.routing.strategy set to "manual". Available only when i18n routing is disabled. See i18n routing Error Reference. Astro components cannot be rendered via function calls. Use component syntax <Component /> or {items.map(item => <Component {...item} />)}. Invalid frontmatter: requires correct schema, e.g., missing required fields or incorrect types. Invalid content entry slug: slug must be a string. Invalid dynamic route. InvalidDynamicRoute: Invalid param. Caused by undefined parameter or missing rest parameter. InvalidFrontmatterInjectionError: remark/rehype plugin attempted to inject invalid frontmatter. Ensure "astro.frontmatter" is valid JSON object. "astro.frontmatter" cannot be null or undefined. InvalidGetStaticPathParam: getStaticPaths params must be an object. Example: return [{params: {slug: "blog"}}]. InvalidGetStaticPathsEntry: Invalid entry returned by getStaticPaths. Expected an object. Return array of objects: [{ params: { slug: "value" } }]. InvalidGetStaticPathsReturn: getStaticPaths must return array of objects. Error: invalid type RETURN_TYPE, expected array. Example: `export async function getStaticPaths() { return [{ params: { slug: "blog" } }] }` Invalid glob pattern: GLOB_PATTERN. Must start with './', '../' or '/'. InvalidImageService: Error loading image service. Check stack trace. InvalidPrerenderExport: Invalid prerender export. Only export const prerender = true is supported. Error LocalImageUsedWrongly: Image’s and getImage’s src parameter must be imported image or URL, not string filepath. LocalsNotAnObject: locals can only be assigned to an object. MarkdownFrontmatterParseError: Error parsing Markdown frontmatter. Caused by syntax errors (e.g., missing colon). ImageNotFound: Image not found. Check the path. MdxIntegrationMissingError: Unable to render FILE. Ensure @astrojs/mdx integration is installed. MiddlewareCantBeLoaded: Error loading middleware. Thrown in development if middleware throws an error. MiddlewareNoDataOrNextCalled: Middleware must return a Response or call next(). MiddlewareNotAResponse: Middleware must return Response object. Error: middleware returned non-Response object. Example: `export const onRequest = defineMiddleware(() => { return new Response() })` Missing image dimensions: For remote images, width and height attributes are required to avoid CLS. Set inferSize to true or specify dimensions. MissingLocale: The locale/path does not exist in i18n.locales. MissingMediaQueryDirective: Missing media query for client:media. Example: client:media="(max-width: 600px)". Error MissingMiddlewareForInternationalization: manual i18n routing requires middleware file when i18n.routing: 'manual' is set. MissingSharp: Could not find Sharp. Install manually (`npm install sharp`) or use passthrough image service. `image: { service: passthroughImageService() }` MixedContentDataCollectionError: Content collection has mixed content/data entries. Store entries separately by type. NoAdapterInstalled: Cannot use output: 'server' or 'hybrid' without an adapter. NoClientEntrypoint: COMPONENT_NAME component has client:CLIENT_DIRECTIVE, but no client entrypoint from RENDERER_NAME. Error: Renderer missing client entrypoint to hydrate component. Solution: Check addRenderer option. Related: Hydrating framework components. Missing hint on `client:only` directive, e.g., ``. NoImageMetadata: Could not process image metadata. Check for corrupted or malformed image. NoMatchingImport: Could not render COMPONENT_NAME. No matching import has been found for COMPONENT_NAME. No matching renderer found. Unable to render component. Install integration for component type (@astrojs/react, @astrojs/vue, etc.). NoMatchingStaticPathFound: No static path found for requested path PATH_NAME in getStaticPaths(). Check for typos. NoPrerenderedRoutesWithDomains: Prerendered routes are not supported with internationalization domains. Error: static pages with i18n domains require disabling prerendering. Invalid type returned. Only Response can be returned from Astro files. Return new Response() or Astro.redirect(). PageNumberParamNotFound: Error. Page number parameter missing in filepath for paginate(). Check filepath and Pagination Error Reference. PrerenderClientAddressNotAvailable: Astro.clientAddress cannot be used in prerendered routes. PrerenderDynamicEndpointPathCollide: Could not render PATHNAME with undefined param due to path collision. Prevent undefined params in getStaticPaths() or add extension to endpoint filename. RedirectWithNoLocation: A redirect must have a Location header. ReservedSlotName: Error when using a reserved slot name. Cannot use reserved words for slot names. ResponseSentError: Response already sent, cannot be altered. Changes to response (headers, cookies, status) must be done inside page components. RewriteEncounteredAnError: Route doesn't exist or emitted an error. Deprecated. RewriteWithBodyUsed: Astro.rewrite() cannot be used after reading the request body. Clone the request first. RouteNotFound: Astro could not find a matching route for the request. ServerOnlyModule: Module "NAME" is server-side only. Error: module unavailable client-side. Astro.clientAddress is only available with output: 'server' or 'hybrid'. In static mode, use client-side script or serverless functions. StaticRedirectNotAvailable: Astro.redirect only available with output: 'server' or output: 'hybrid'. Use meta refresh for static sites. UnhandledRejection: Ensure all Promises have await or .catch() handlers. Unknown CLI Error: Astro CLI command failed. Check error message for details. Open an issue if reproducible. Unknown compiler error. Unknown configuration error: Error loading Astro configuration file, often caused by a syntax error. Unknown Content Collection Error. Error loading content collections; check src/content/config.ts. Unknown CSS Error: Astro encountered an unknown error while parsing CSS. UnknownFilesystemError: Unknown error reading/writing files. Caused by missing permissions or file not existing. Unknown Markdown Error: Syntax error in Markdown. Unknown Vite Error. Vite encountered an unknown error. UnsupportedConfigTransformError: transform() must return valid JSON or devalue-compatible data types (Dates, Maps, Sets). UnsupportedImageConversion: Error. Converting between vector (SVG) and raster (PNG, JPEG) images is not supported. See Images Error Reference. UnsupportedImageFormat: Unsupported image format. Only SUPPORTED_FORMATS supported. Use <img> tag for other formats. Image Service API: astro:assets. Local services transform images at build/runtime. External services point to URLs. ExternalImageService: validateOptions(options, imageConfig), getURL(options, imageConfig) returns URL string, getHTMLAttributes(options, imageConfig) returns HTML attributes. LocalImageService: getURL(options, imageConfig) returns URL string, parseURL(url, imageConfig) returns {src, [key: string]: any}, transform(buffer, options, imageConfig) returns {data, format}, getHTMLAttributes(options, imageConfig). getConfiguredImageService & imageConfig: For custom endpoints. ImageTransform: {src, width?, height?, widths?, densities?, quality?, format?, alt?, [key: string]: any}. SrcSetValue: {transform: ImageTransform, descriptor?: string, attributes?: Record}. astro.config.mjs: image: {service: {entrypoint, config?}} AstroIntegration: Adds functionality via hooks. Hooks: astro:config:setup(options): config, command, isRestart, updateConfig, addRenderer, addClientDirective, addMiddleware, addDevToolbarApp, addWatchFile, injectScript, injectRoute, logger. astro:config:done(options): config, setAdapter, injectTypes, logger. astro:route:setup(options): route, logger. astro:server:setup(options): server, logger. astro:server:start(options): address, logger. astro:server:done(options): logger. astro:build:start(options): logger. astro:build:setup(options): vite, pages, target, logger. astro:build:generated(options): dir, logger. astro:build:ssr(options): manifest, entryPoints, logger. astro:build:done(options): dir, routes, logger. AstroIntegrationLogger: info, warn, error, debug, fork. Upgrade Astro: Guide to updating Astro and dependencies. Follows semantic versioning (X.Y.Z): patch (Z), minor (Y), major (X). Major releases have breaking changes. Use npm/pnpm/yarn to upgrade.